package api

import (
	"fmt"
	"net/http"
	"strconv"

	"github.com/merico-dev/lake/config"
	"github.com/merico-dev/lake/models/common"

	"github.com/go-playground/validator/v10"
	"github.com/merico-dev/lake/plugins/core"
	"github.com/merico-dev/lake/plugins/tapd/models"
	"github.com/mitchellh/mapstructure"
)

func findSourceByInputParam(input *core.ApiResourceInput) (*models.TapdSource, error) {
	sourceId := input.Params["sourceId"]
	if sourceId == "" {
		return nil, fmt.Errorf("missing sourceid")
	}
	tapdSourceId, err := strconv.ParseUint(sourceId, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid sourceId")
	}

	return getTapdSourceById(tapdSourceId)
}

func getTapdSourceById(id uint64) (*models.TapdSource, error) {
	tapdSource := &models.TapdSource{}
	err := db.First(tapdSource, id).Error
	if err != nil {
		return nil, err
	}

	// decrypt
	v := config.GetConfig()
	encKey := v.GetString(core.EncodeKeyEnvStr)
	tapdSource.BasicAuthEncoded, err = core.Decrypt(encKey, tapdSource.BasicAuthEncoded)
	if err != nil {
		return nil, err
	}

	return tapdSource, nil
}
func mergeFieldsToTapdSource(tapdSource *models.TapdSource, sources ...map[string]interface{}) error {
	// decode
	for _, source := range sources {
		err := mapstructure.Decode(source, tapdSource)
		if err != nil {
			return err
		}
	}

	// validate
	vld := validator.New()
	err := vld.Struct(tapdSource)
	if err != nil {
		return err
	}

	return nil
}

func refreshAndSaveTapdSource(tapdSource *models.TapdSource, data map[string]interface{}) error {
	var err error
	// update fields from request body
	err = mergeFieldsToTapdSource(tapdSource, data)
	if err != nil {
		return err
	}

	// encrypt
	v := config.GetConfig()
	encKey := v.GetString(core.EncodeKeyEnvStr)
	if encKey == "" {
		// Randomly generate a bunch of encryption keys and set them to config
		encKey = core.RandomEncKey()
		v.Set(core.EncodeKeyEnvStr, encKey)
		err := v.WriteConfig()
		if err != nil {
			return err
		}
	}
	tapdSource.BasicAuthEncoded, err = core.Encrypt(encKey, tapdSource.BasicAuthEncoded)
	if err != nil {
		return err
	}

	// transaction for nested operations
	tx := db.Begin()
	defer func() {
		if err != nil {
			tx.Rollback()
		} else {
			tx.Commit()
		}
	}()
	if tapdSource.ID > 0 {
		err = tx.Save(tapdSource).Error
	} else {
		err = tx.Create(tapdSource).Error
	}
	if err != nil {
		if common.IsDuplicateError(err) {
			return fmt.Errorf("tapd source with name %s already exists", tapdSource.Name)
		}
		return err
	}
	//// perform optional operation
	//typeMappings := data["typeMappings"]
	//if typeMappings != nil {
	//	err = saveTypeMappings(tx, tapdSource.ID, typeMappings)
	//	if err != nil {
	//		return err
	//	}
	//}

	return nil
}

/*
POST /plugins/tapd/sources
{
	"name": "tapd data source name",
	"endpoint": "tapd api endpoint, i.e. https://merico.atlassian.net/rest",
	"basicAuthEncoded": "generated by `echo -n <tapd login email>:<tapd token> | base64`",
	"epicKeyField": "name of customfield of epic key",
	"storyPointField": "name of customfield of story point",
	"typeMappings": { // optional, send empty object to delete all typeMappings of the data source
		"userType": {
			"standardType": "devlake standard type",
			"statusMappings": {  // optional, send empt object to delete all status mapping for the user type
				"userStatus": {
					"standardStatus": "devlake standard status"
				}
			}
		}
	}
}
*/
func PostSources(input *core.ApiResourceInput) (*core.ApiResourceOutput, error) {
	// create a new source
	tapdSource := &models.TapdSource{}

	// update from request and save to database
	err := refreshAndSaveTapdSource(tapdSource, input.Body)
	if err != nil {
		return nil, err
	}

	return &core.ApiResourceOutput{Body: tapdSource, Status: http.StatusCreated}, nil
}

/*
PUT /plugins/tapd/sources/:sourceId
{
	"name": "tapd data source name",
	"endpoint": "tapd api endpoint, i.e. https://merico.atlassian.net/rest",
	"basicAuthEncoded": "generated by `echo -n <tapd login email>:<tapd token> | base64`",
	"epicKeyField": "name of customfield of epic key",
	"storyPointField": "name of customfield of story point",
	"typeMappings": { // optional, send empty object to delete all typeMappings of the data source
		"userType": {
			"standardType": "devlake standard type",
			"statusMappings": {  // optional, send empt object to delete all status mapping for the user type
				"userStatus": {
					"standardStatus": "devlake standard status"
				}
			}
		}
	}
}
*/
func PutSource(input *core.ApiResourceInput) (*core.ApiResourceOutput, error) {
	// load from db
	tapdSource, err := findSourceByInputParam(input)
	if err != nil {
		return nil, err
	}

	// update from request and save to database
	err = refreshAndSaveTapdSource(tapdSource, input.Body)
	if err != nil {
		return nil, err
	}

	return &core.ApiResourceOutput{Body: tapdSource}, nil
}

/*
DELETE /plugins/tapd/sources/:sourceId
*/
func DeleteSource(input *core.ApiResourceInput) (*core.ApiResourceOutput, error) {
	// load from db
	tapdSource, err := findSourceByInputParam(input)
	if err != nil {
		return nil, err
	}
	err = db.Delete(tapdSource).Error
	if err != nil {
		return nil, err
	}
	// cascading delete
	err = db.Where("source_id = ?", tapdSource.ID).Delete(&models.TapdIssueTypeMapping{}).Error
	if err != nil {
		return nil, err
	}
	err = db.Where("source_id = ?", tapdSource.ID).Delete(&models.TapdIssueStatusMapping{}).Error
	if err != nil {
		return nil, err
	}

	return &core.ApiResourceOutput{Body: tapdSource}, nil
}

/*
GET /plugins/tapd/sources
*/
func ListSources(input *core.ApiResourceInput) (*core.ApiResourceOutput, error) {
	tapdSources := make([]models.TapdSource, 0)
	err := db.Find(&tapdSources).Error
	if err != nil {
		return nil, err
	}
	return &core.ApiResourceOutput{Body: tapdSources}, nil
}

/*
GET /plugins/tapd/sources/:sourceId


{
	"name": "tapd data source name",
	"endpoint": "tapd api endpoint, i.e. https://merico.atlassian.net/rest",
	"basicAuthEncoded": "generated by `echo -n <tapd login email>:<tapd token> | base64`",
	"epicKeyField": "name of customfield of epic key",
	"storyPointField": "name of customfield of story point",
	"typeMappings": { // optional, send empty object to delete all typeMappings of the data source
		"userType": {
			"standardType": "devlake standard type",
			"statusMappings": {  // optional, send empt object to delete all status mapping for the user type
				"userStatus": {
					"standardStatus": "devlake standard status"
				}
			}
		}
	}
}
*/
func GetSource(input *core.ApiResourceInput) (*core.ApiResourceOutput, error) {
	tapdSource, err := findSourceByInputParam(input)
	if err != nil {
		return nil, err
	}

	detail := &models.TapdSourceDetail{
		TapdSource:   *tapdSource,
		TypeMappings: make(map[string]map[string]interface{}),
	}

	//typeMappings, err := findIssueTypeMappingBySourceId(tapdSource.ID)
	//if err != nil {
	//	return nil, err
	//}
	//for _, tapdTypeMapping := range typeMappings {
	//	// type mapping
	//	typeMappingDict := map[string]interface{}{
	//		"standardType": tapdTypeMapping.StandardType,
	//	}
	//	detail.TypeMappings[tapdTypeMapping.UserType] = typeMappingDict
	//
	//	// status mapping
	//	statusMappings, err := findIssueStatusMappingBySourceIdAndUserType(
	//		tapdSource.ID,
	//		tapdTypeMapping.UserType,
	//	)
	//	if err != nil {
	//		return nil, err
	//	}
	//	if len(statusMappings) == 0 {
	//		continue
	//	}
	//	statusMappingsDict := make(map[string]interface{})
	//	for _, tapdStatusMapping := range statusMappings {
	//		statusMappingsDict[tapdStatusMapping.UserStatus] = map[string]interface{}{
	//			"standardStatus": tapdStatusMapping.StandardStatus,
	//		}
	//	}
	//	typeMappingDict["statusMappings"] = statusMappingsDict
	//}

	return &core.ApiResourceOutput{Body: detail}, nil
}

// GET /plugins/tapd/sources/:sourceId/epics
type EpicResponse struct {
	Id    int
	Title string
	Value string
}

func GetEpicsBySourceId(input *core.ApiResourceInput) (*core.ApiResourceOutput, error) {
	tapdSource, err := findSourceByInputParam(input)
	if err != nil {
		return nil, err
	}
	return &core.ApiResourceOutput{Body: [1]EpicResponse{{
		Id:    1,
		Title: tapdSource.EpicKeyField,
		Value: tapdSource.EpicKeyField,
	}}}, nil
}

// GET /plugins/tapd/sources/:sourceId/granularities
type GranularitiesResponse struct {
	Id    int
	Title string
	Value string
}

func GetGranularitiesBySourceId(input *core.ApiResourceInput) (*core.ApiResourceOutput, error) {
	tapdSource, err := findSourceByInputParam(input)
	if err != nil {
		return nil, err
	}
	return &core.ApiResourceOutput{Body: [1]GranularitiesResponse{
		{
			Id:    1,
			Title: "Story Point Field",
			Value: tapdSource.StoryPointField,
		},
	}}, nil
}

type WorkspaceResponse struct {
	Id    int
	Title string
	Value string
}

// GET /plugins/tapd/sources/:sourceId/boards

func GetBoardsBySourceId(input *core.ApiResourceInput) (*core.ApiResourceOutput, error) {
	sourceId := input.Params["sourceId"]
	if sourceId == "" {
		return nil, fmt.Errorf("missing sourceid")
	}
	tapdSourceId, err := strconv.ParseUint(sourceId, 10, 64)
	if err != nil {
		return nil, fmt.Errorf("invalid sourceId")
	}
	var tapdWorkspaces []models.TapdWorkspace
	err = db.Where("source_Id = ?", tapdSourceId).Find(&tapdWorkspaces).Error
	if err != nil {
		return nil, err
	}
	var workSpaceResponses []WorkspaceResponse
	for _, workSpace := range tapdWorkspaces {
		workSpaceResponses = append(workSpaceResponses, WorkspaceResponse{
			Id:    int(workSpace.ID),
			Title: workSpace.Name,
			Value: fmt.Sprintf("%v", workSpace.ID),
		})
	}
	return &core.ApiResourceOutput{Body: workSpaceResponses}, nil
}
